"""
Module with the concrete implementation of the
first level of the Diamondus world.
"""
from typing import Dict
from typing import Optional

from jazzpy.levels.level import Level
from jazzpy.sprites.platforms.platforms import Platform


class DiamondusLevelOne(Level):
    """
    Concrete implementation of the abstract class Level
    for the first stage of the game of the Diamondus world.
    """

    COLLIDABLE_PLATFORMS = {
        "T1": (32, 193, 32, 32),  # T1
        "F1": (64, 416, 32, 32),  # standard fill
        "F2": (96, 193, 32, 32),  # small diamonds
        "F3": (63, 225, 26, 29),  # red diamond
        "F4": (38, 226, 26, 29),  # teal diamond
        "F5": (2, 226, 26, 29),  # green diamond
        "F6": (193, 353, 31, 31),  # pre ramp left <-
        "F0": (161, 354, 29, 30),  # pre ramp right ->
        "F7": (167, 293, 51, 51),  # full diamonds
        "F8": (99, 286, 28, 30),  # F8 right
        "F9": (4, 320, 28, 28),  # F9  left
        "R1": (257, 352, 31, 31),  # R1 down ramp
        "R2": (96, 352, 32, 30),  # U1  up ramp
        "C1": (129, 224, 26, 27),  # corner left /
        "C2": (101, 288, 27, 30),  # corner right \
        "EDGE_GRASS_SPRITE_LEFT_1": (164, 191, 28, 32),  # E1
        "EDGE_GRASS_SPRITE_RIGHT_1": (219, 192, 28, 32),  # E2
    }

    NON_COLLIDABLE_PLATFORMS = {"A1": (97, 129, 33, 48)}

    # def level_char_code_to_platform(self, level_char_code, level_x, level_y):
    #     """
    #     Non-abstract implementation of the method that converts level_char_codes
    #     into Platform objects at the right positions of the level.
    #     """
    #     platform_dimensions = (self.platforms_width, self.platforms_height)
    #     sprite_tuple = self.COLLIDABLE_PLATFORMS.get(level_char_code)
    #
    #     if sprite_tuple:
    #         image = self.sprite_sheet.get_image(sprite_tuple, dimensions=platform_dimensions)
    #
    #         return Platform(level_x, level_y, image)
    #
    #     sprite_tuple = self.NON_COLLIDABLE_PLATFORMS.get(level_char_code)
    #
    #     if sprite_tuple:
    #         image = self.sprite_sheet.get_image(sprite_tuple, dimensions=platform_dimensions)
    #
    #         return Platform(level_x, level_y, image, is_collidable=False)
    #
    #     # sprite tuple was not found
    #     if level_char_code == "JJ":
    #         self.jazz_initial_x, self.jazz_initial_y = level_x, level_y
    #
    #     return None

    # def _get_spritesheet_row(self, level_char_code_slice):
    #     if level_char_code_slice[0] != "R":
    #         raise RuntimeError("ERROR: NO R!")
    #
    #     if level_char_code_slice[]

    def _get_level_char_code_info(self, level_char_code: str) -> Dict:
        """
        Parses the level_char_code in order to extract informartion about the Platform
        to be created for the level.

        Example:
            "MCR09C09" --> M: Map spritesheet, C: collidable, R09: row of the spritesheet,
                           C09: col of the spritesheet.
        """
        # TODO: implement a way to use other spritesheet files
        spritesheet_to_use = self.sprite_sheet if level_char_code[0] == "M" else self.sprite_sheet
        is_platform_collidable = True if level_char_code[1] == "C" else False

        spritesheet_row = int(level_char_code[3:5])
        spritesheet_col = int(level_char_code[6:8])

        return {
            "spritesheet_to_use": spritesheet_to_use,
            "is_platform_collidable": is_platform_collidable,
            "spritesheet_row": spritesheet_row,
            "spritesheet_col": spritesheet_col,
        }

    def level_char_code_to_platform(
        self, level_char_code: str, level_x: int, level_y: int
    ) -> Optional[Platform]:
        """
        Non-abstract implementation of the method that converts level_char_codes
        into Platform objects at the right positions of the level.
        """
        if level_char_code == self.no_platform_level_char_code:
            return None

        # attempts to deal immediately with Jazz position
        if level_char_code == self.jazz_level_char_code:
            self.jazz_initial_x, self.jazz_initial_y = level_x, level_y

            return None

        platform_dimensions = (self.platforms_width, self.platforms_height)
        level_char_code_info = self._get_level_char_code_info(level_char_code)

        if level_char_code_info:
            image = self.sprite_sheet.get_image_by_row_and_col(
                spritesheet_row=level_char_code_info["spritesheet_row"],
                spritesheet_col=level_char_code_info["spritesheet_col"],
                dimensions=platform_dimensions,
            )

            return Platform(
                level_x,
                level_y,
                image,
                is_collidable=level_char_code_info["is_platform_collidable"],
            )

        return None  # no platform was generated by this level_char_code
